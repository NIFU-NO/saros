
#' Adds Text Interpretations to Selected Variables in Design Frame
#' 
#' Based on the inputs, adds semi-random text interpretations for text-based
#'     report generation.
#'
#' @param obj An object as generated by `create_infoframe()` or as returned
#'    by the other add_* functions.
#' @param template_xlsx Path to translations file. 
#' #'     Set as NULL for built-in examples, which is also available by calling 
#'     `data("template_translations", package="surveyreport")`. Save this to 
#'     disk, modify according to your needs, then read back in using 
#'     `readxl::read_excel("my_translations.xlsx")`. File must contain the 
#'     following three columns. 
#' \itemize{
#' \item{type}{Types of strings to randomize between. Will also become column 
#'     names in design_frame.}
#' \item{regex}{Regular expression: this is used to select filter y_group_label 
#'     for which the str is to be used.}
#' \item{str}{A glue-based string template for building sentences.} 
#' }
#' @param seed Temporary seed number for random number generation. If not NULL,
#'     will randomize among options for a given type.
#' @param first_mention What principle to use for selecting the first category
#'     being mentioned when comparing categories. 
#' @return obj. design_frame will have added a column for each unique `type`,
#'     named interpret_*.
#' @importFrom dplyr rowwise mutate ungroup %>% pull filter across starts_with
#' @importFrom readxl read_excel
#' @importFrom rlang %||% abort arg_match set_names .data .env
#' @importFrom purrr map_dfc pmap_chr pmap_dfr
#' @importFrom tidyr pivot_longer pivot_wider separate
#' @importFrom glue glue
#' @importFrom utils str

#'
#' @examples
#' #ex_survey1_inf_new <- add_percentage(ex_survey1_inf)
#' #ex_survey1_inf_new <- add_interpretation(ex_survey1_inf_new)
#' #ex_survey1_inf_new$design_frame[, grepl("interpret_", names(obj$design_frame))]
#' 
add_interpretation <- function(obj, 
					 template_xlsx=NULL, 
					 first_mention=c("high_p", "low_p", "high_n", "small_n", "high_cat", "small_cat", "str_first_cat"),
					 seed = 1) {
	assert_valid_infoframe(obj)

	template_xlsx <- 
		template_xlsx %||% 
		system.file("template", "text_translations_template.xlsx", 
					package = "surveyreport", mustWork = TRUE)
	first_mention <- rlang::arg_match(arg = first_mention)

	trans <- readxl::read_excel(path = template_xlsx, col_types = "text", trim_ws = FALSE, sheet = 1L, progress = FALSE)
	names(trans) <- tolower(names(trans))
	if(!all(c("type", "regex", "str") %in% names(trans))) {
		rlang::abort(message = c("Unable to find columns:", 
								 i="template_xlsx must contain (at least) columns named `type`, `regex`, and `str`.",
								 x="Columns provided are ", 
								 rlang::quo_text(names(trans))))
	}
	str_vars <- unique(unlist(regmatches(trans$str, gregexpr("(?<=\\{)[^{}]+(?=\\})", trans$str, perl=TRUE))))
	str_vars <- gsub("tolower\\(|\\)", "", str_vars)
	str_vars <- gsub("toupper\\(|\\)", "", str_vars)
	str_vars_unavail <- str_vars[!str_vars %in% names(obj$design_frame)]
	if(length(str_vars_unavail)>0L) rlang::abort(c(x=paste0("Unable to find ", 
												   rlang::quo_text(str_vars_unavail), 
												   " in obj$design_frame."),
												   i="Consider running add_percentage() or add_analyses() first."))

	df_tmp <-
		unique(trans$type) %>%
		rlang::set_names(nm = paste0("interpret_", .)) %>%
		purrr::map_dfc(.x = ., .f = function(t) {
			

			# X <-
			purrr::pmap_chr(obj$design_frame, function(...) { #Place this at innermost loop

				y_group_label <- rlang::dots_list(..., .named = TRUE)
				y_group_label <- y_group_label$y_group_label

				
				trans_a_type <- 
					dplyr::filter(trans, .data$type == .env$t) %>% 
					dplyr::distinct(.data$regex, .data$str)
				Y <-
				unique(trans_a_type$regex) %>%
					rlang::set_names() %>%
					purrr::map_chr(.x=., .f = function(reg) {
						str_selected <- 
							dplyr::filter(trans, .data$type == .env$t, .data$regex == .env$reg) %>% 
							dplyr::pull(.data$str) %>% 
							unique()
							
						if(length(str_selected)>0L && grepl(reg, y_group_label, ignore.case = TRUE)) {
							sample(str_selected, size = 1L) 
							} else ""
						}) %>% 
					.[nchar(.)!=0L] %>% unique() %>%  
					paste0(collapse="")
				# print(Y)
				# Y
			})
			# print(head(X))
			# X
		})
	design_frame <- 
		cbind(obj$design_frame, df_tmp) %>%
		dplyr::rowwise() %>%
		dplyr::mutate(dplyr::across(dplyr::starts_with(.env$out_col_prefix), 
									~ifelse(test = nchar(.x) > 0L, 
											yes = as.character(glue::glue(.x)), 
											no = .x))) %>%
		dplyr::ungroup()
	
	list(df=obj$df, var_frame=obj$var_frame, design_frame=design_frame)
}
