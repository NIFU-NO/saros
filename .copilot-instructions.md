# AI Running Command Instructions
- Whenever running commands, always run in PowerShell, not Command Prompt on Windows.
- When installing the R package, always use `R.exe --no-echo --no-restore -e "devtools::install()"`.
- When checking the R package, always use `R.exe --no-echo --no-restore -e "devtools::check()"`.
- When testing the R package, always use `R.exe --no-echo --no-restore -e "devtools::test()"`.


# AI Git Workflow Instructions

## Command: "git"

When the user says "git", execute this complete workflow:

### 1. Check for Changes and PR Status
- Run `git status` and `git diff` to identify all uncommitted changes
- Check if current branch has an active PR using `gh pr list --head [branch]`
- If active PR exists, warn user and ask for confirmation before proceeding
- Analyze the types of changes (bug fixes, features, refactoring, documentation, linting)

### 2. Branch Strategy
- Create appropriate branches based on change types:
  - Single `dev` branch if changes are cohesive/related
  - Multiple feature branches if changes are distinct:
    - `feature/bug-fixes` - for bug fixes
    - `feature/new-features` - for new functionality
    - `refactor/code-cleanup` - for refactoring/cleanup
    - `docs/updates` - for documentation changes
    - `style/formatting` - for linting/formatting (always last)
- If working on existing branch with active PR, create new branch from current main

### 3. Sync with Main Branch
- Always fetch and pull latest changes from `origin/main`
- Create new branches from updated main to avoid conflicts
- If current branch is behind main, offer to rebase or create fresh branch

### 4. Update Documentation FIRST
- Check if changes need to be documented in `NEWS.md`
- Add appropriate changelog entries if missing
- Use the current version from `DESCRIPTION` file
- Commit documentation changes BEFORE code changes

### 5. Commit Strategy
- Create separate commits for each logical group of changes
- Use conventional commit format:
  - `feat:` for new features
  - `fix:` for bug fixes
  - `refactor:` for code improvements
  - `docs:` for documentation
  - `style:` for formatting/linting
  - `dev:` for development setup
- Commit linting/formatting changes LAST within each branch

### 6. Pre-Push Validation
- Check PR status again before pushing: `gh pr list --head [branch]`
- If PR exists and is merged, create new branch for remaining commits
- Run basic validation (syntax check) if possible

### 7. Push and Create PRs Safely
- Push branches to remote only after all commits are ready
- Before creating PR, verify branch hasn't been merged: `gh pr view [number] --json state`
- Create GitHub Pull Requests using `gh pr create` with:
  - Descriptive titles based on changes
  - Detailed descriptions with proper sections (Problem, Solution, Testing)
  - Reference related issues with "Fixes #XXX" or "Closes #XXX"
  - Use draft PRs if work is incomplete

### 8. Workflow Completion and Safeguards
- Verify all PRs are created successfully using `gh pr list`
- Check that no commits are left uncommitted or unpushed
- Provide summary of all branches and PRs created with URLs
- Show next steps for the user
- If any PRs were already merged during process, create follow-up PRs for orphaned commits

## Safety Checks
- **Always check PR status before pushing more commits**
- **Create new branches from main if current PR is merged**
- **Document changes BEFORE committing code**
- **Validate that all commits reach their intended PRs**
- **Use descriptive branch names with issue numbers when applicable**

## Recovery Pattern
If commits become orphaned (PR merged while working):
1. Create new branch from current main: `git checkout main && git pull && git checkout -b fix/issue-XXX`
2. Cherry-pick orphaned commits: `git cherry-pick <commit-hash>`
3. Create focused PR for the specific issue/feature
4. Update documentation to reflect the fix

## Example Usage
User types: "git"
AI executes: Complete workflow from uncommitted changes → branches → commits → PRs

## Requirements
- GitHub CLI (`gh`) installed and authenticated
- Proper git configuration
- VS Code with GitHub Copilot (recommended)